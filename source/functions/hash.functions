function hash_recordHashes()
{
	local -r prefix="$1"
	local -r path="$2"
	local -r hashesFileParentPath="$3"
	local -r hashesFileName="$4"
	local -r hashesInstalledFileName="$5"
	
	local -r sortedAsciiNullSeparatedFiles="$hashesFileParentPath"/"$hashesFileName"
	local -r hashesInstalledFilePath="$hashesFileParentPath"/"$hashesInstalledFileName"
	local -r topLevelFolder="${prefix}${path}"
	local -ir prefixLength=${#prefix}
	
	# Done this way, instead of < <(coproc command), to overcome an open files bug?
	temporaryFiles_newFileToRemoveOnExit
	local -r coprocTemporaryFile="$TMP_FILE"
	
	hash_recordFiles
	hash_recordHashesInFile
}

function hash_recordFiles()
{
	find "$topLevelFolder" -print0 | LC_ALL=C sort -k 1 -z >"$sortedAsciiNullSeparatedFiles"
}

function hash_recordHashesInFile()
{
	hash_recordHashLine Type Uid Gid Mode MTime CTime Meta Version Chattr Acl DefaultAcl Selinux Capabilities Size MD5 SHA1 SHA256 SHA512 Path
	
	local fileObject
	while IFS= read -r -d $'\0' fileObject
	do
		# symlinks first as all other tests cause de-referencing of symlinks
		if [ -h "$fileObject" ]; then
			hash_recordHashSymlink
		elif [ -f "$fileObject" ]; then
			hash_recordHashFile
		elif [ -d "$fileObject" ]; then
			hash_recordHashFolder
		elif [ -b "$fileObject" ]; then
			hash_recordHashDevice b
		elif [ -c "$fileObject" ]; then
			hash_recordHashDevice c
		elif [ -p "$fileObject" ]; then
			hash_recordHashNamedPipe
		elif [ -S "$fileObject" ]; then
			hash_recordHashSocket
		else
			informationMessage FAIL "Unknown file type $fileObject"
			exitError 1
		fi
	done <"$sortedAsciiNullSeparatedFiles"
}

function hash_recordHashLine()
{
	case $# in
		
		18)
			local -r filePath="${fileObject:$prefixLength}"
		;;
		
		19)
			local -r filePath="$19"
		;;
		
		*)
			informationMessage FAIL "Not 18 or 19 arguments"
			exitError 1
		;;
	
	esac
	
	local -r fileType="$1"
	local -r uid="$2"
	local -r gid="$3"
	local -r mode="$4"
	local -r mtime="$5"
	local -r ctime="$6"
	local -r meta="$7"
	local -r version="$8"
	local -r chattr="$9"
	local -r acl="$10"
	local -r defaultacl="$11"
	local -r selinux="$12"
	local -r capabilities="$13"
	local -r size="$14"
	local -r md5="$15"
	local -r sha1="$16"
	local -r sha256="$17"
	local -r sha512="$18"
	
	printf '%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n' "$fileType" "$uid" "$gid" "$mode" "$mtime" "$ctime" "$meta" "$version" "$chattr" "$acl" "$defaultacl" "$selinux" "$capabilities" "$size" "$md5" "$sha1" "$sha256" "$sha512" "${filePath}" >>"$hashesInstalledFilePath"
}

# birthTime %W seems to not be known for most files (outputs 0)
# atime %X is not very useful

function hash_recordHashSymlink()
{
	local uid gid mode mtime ctime size
	stat -c "%u %g %a %Y %Z %s" "$fileObject" >"$coprocTemporaryFile"
	IFS=' ' read -r -d $'\n' uid gid mode size <"$coprocTemporaryFile"
	
	local -r meta="$(readlink -n "$fileObject")"
		
	# selinux uses %C, seems to be hard to get; if unknown or unsupported, '?' is returned
	local -r selinux="$(stat -c '%C' "$fileObject" 2>/dev/null || true)"
	
	local -r md5="$(echo -n "$meta" | md5sum | awk 'NR==1 {print $1}')"
	local -r sha1="$(echo -n "$meta" | sha1sum | awk 'NR==1 {print $1}')"
	local -r sha256="$(echo -n "$meta" | sha256sum | awk 'NR==1 {print $1}')"
	local -r sha512="$(echo -n "$meta" | sha512sum | awk 'NR==1 {print $1}')"
	
	hash_recordHashLine l "$uid" "$gid" "$mode" "$mtime" "$ctime" "$meta" '' '' '' '' "$selinux" '' "$size" "$md5" "$sha1" "$sha256" "$sha512"
}

function hash_recordHashFile()
{
	local uid gid mode mtime ctime size
	stat -c "%u %g %a %Y %Z %s" "$fileObject" >"$coprocTemporaryFile"
	IFS=' ' read -r -d $'\n' uid gid mode size <"$coprocTemporaryFile"
	
	local -r meta="$(file --brief --keep-going --no-dereference --uncompress "$fileObject")"
	
	local version chattr file
	lsattr -v "$fileObject" >"$coprocTemporaryFile"
	IFS=' ' read -r -d $'\n' version chattr file <"$coprocTemporaryFile"
	
	local -r initialAcl="$(getfacl --absolute-names --omit-header --physical --numeric --no-effective --skip-base --access -- "$fileObject" | grep -v -E '^(user|group|other)::' | grep -v '^$' | tr '\n' ' ')"
	if [ -n "$initialAcl" ]; then
		# strips a trailing ' '
		local -r acl="${initialAcl:0:-1}"
	else
		local -r acl=""
	fi
	
	# selinux uses %C, seems to be hard to get; if unknown or unsupported, '?' is returned
	local -r selinux="$(stat -c '%C' "$fileObject" 2>/dev/null || true)"
	
	local -r capabilities="$(getcap "$fileObject" | awk '{print $3}')"
	
	local -r md5="$(md5sum "$fileObject" | awk 'NR==1 {print $1}')"
	local -r sha1="$(sha1sum "$fileObject" | awk 'NR==1 {print $1}')"
	local -r sha256="$(sha256sum "$fileObject" | awk 'NR==1 {print $1}')"
	local -r sha512="$(sha512sum "$fileObject" | awk 'NR==1 {print $1}')"
	
	hash_recordHashLine f "$uid" "$gid" "$mode" "$mtime" "$ctime" "$meta" "$version" "$chattr" "$acl" '' "$selinux" "$capabilities" "$size" "$md5" "$sha1" "$sha256" "$sha512"
}

function hash_recordHashFolder()
{
	# Whilst folders do have a size, it's very much a function of the file system
	local uid gid mode mtime ctime
	stat -c "%u %g %a %Y %Z" "$fileObject" >"$coprocTemporaryFile"
	IFS=' ' read -r -d $'\n' uid gid mode mtime ctime <"$coprocTemporaryFile"
	
	# it might be useful to record entry count, less . and .. as 'meta', or perhaps an ignore-rule
	
	# Note -d to make lsattr behave
	local version chattr file
	lsattr -d -v "$fileObject" >"$coprocTemporaryFile"
	IFS=' ' read -r -d $'\n' version chattr file <"$coprocTemporaryFile"
	
	local -r initialAcl="$(getfacl --absolute-names --omit-header --physical --numeric --no-effective --skip-base --access -- "$fileObject" | grep -v -E '^(user|group|other)::' | grep -v '^$' | tr '\n' ' ')"
	if [ -n "$initialAcl" ]; then
		# strips a trailing ' '
		local -r acl="${initialAcl:0:-1}"
	else
		local -r acl=""
	fi
	
	# Only folders have default acl
	local -r initialDefaultAcl="$(getfacl --absolute-names --omit-header --physical --numeric --no-effective --skip-base --default -- "$fileObject" | grep -v -E '^(user|group|other)::' | grep -v '^$' | tr '\n' ' ')"
	if [ -n "$initialDefaultAcl" ]; then
		# strips a trailing ' '
		local -r defaultAcl="${initialDefaultAcl:0:-1}"
	else
		local -r defaultAcl=""
	fi
	
	# selinux uses %C, seems to be hard to get; if unknown or unsupported, '?' is returned
	local -r selinux="$(stat -c '%C' "$fileObject" 2>/dev/null || true)"
	
	hash_recordHashLine d "$uid" "$gid" "$mode" "$mtime" "$ctime" '' "$version" "$chattr" "$acl" "$defaultAcl" "$selinux" '' "$size" '' '' '' ''
}

function hash_recordHashDevice()
{
	local -r fileType="$1"
	
	# Whilst devices do have a size, it's very much a function of the file system
	local uid gid mode mtime ctime meta
	stat -c "%u %g %a %Y %Z %t:%T" "$fileObject" >"$coprocTemporaryFile"
	IFS=' ' read -r -d $'\n' uid gid mode mtime ctime meta <"$coprocTemporaryFile"
	
	local -r initialAcl="$(getfacl --absolute-names --omit-header --physical --numeric --no-effective --skip-base --access -- "$fileObject" | grep -v -E '^(user|group|other)::' | grep -v '^$' | tr '\n' ' ')"
	if [ -n "$initialAcl" ]; then
		# strips a trailing ' '
		local -r acl="${initialAcl:0:-1}"
	else
		local -r acl=""
	fi
	
	# selinux uses %C, seems to be hard to get; if unknown or unsupported, '?' is returned
	local -r selinux="$(stat -c '%C' "$fileObject" 2>/dev/null || true)"
	
	hash_recordHashLine "$fileType" "$uid" "$gid" "$mode" "$mtime" "$ctime" "$meta" '' '' "$acl" '' "$selinux" '' '' '' '' '' ''
}

function hash_recordHashNamedPipe()
{
	# Whilst devices do have a size, it's very much a function of the file system
	local uid gid mode mtime ctime
	stat -c "%u %g %a %Y %Z" "$fileObject" >"$coprocTemporaryFile"
	IFS=' ' read -r -d $'\n' uid gid mode mtime ctime <"$coprocTemporaryFile"
	
	local -r initialAcl="$(getfacl --absolute-names --omit-header --physical --numeric --no-effective --skip-base --access -- "$fileObject" | grep -v -E '^(user|group|other)::' | grep -v '^$' | tr '\n' ' ')"
	if [ -n "$initialAcl" ]; then
		# strips a trailing ' '
		local -r acl="${initialAcl:0:-1}"
	else
		local -r acl=""
	fi
	
	# selinux uses %C, seems to be hard to get; if unknown or unsupported, '?' is returned
	local -r selinux="$(stat -c '%C' "$fileObject" 2>/dev/null || true)"
		
	hash_recordHashLine p "$uid" "$gid" "$mode" "$mtime" "$ctime" '' '' '' "$acl" '' "$selinux" '' '' '' '' '' ''
}

function hash_recordHashSocket()
{
	local uid gid mode mtime ctime
	stat -c "%u %g %a %Y %Z" "$fileObject" >"$coprocTemporaryFile"
	IFS=' ' read -r -d $'\n' uid gid mode mtime ctime <"$coprocTemporaryFile"
	
	local -r initialAcl="$(getfacl --absolute-names --omit-header --physical --numeric --no-effective --skip-base --access -- "$fileObject" | grep -v -E '^(user|group|other)::' | grep -v '^$' | tr '\n' ' ')"
	if [ -n "$initialAcl" ]; then
		# strips a trailing ' '
		local -r acl="${initialAcl:0:-1}"
	else
		local -r acl=""
	fi
	
	hash_recordHashLine s "$uid" "$gid" "$mode" "$mtime" "$ctime" '' '' '' "$acl" '' '' '' '' '' '' '' ''
}
