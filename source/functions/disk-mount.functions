disk_mount_functions=()

function disk_mount_createSpareFile()
{
	rm -rf "${machineDisksConfigurationDiskImagePath["$disk"]}"
	truncate -s "${machineDisksConfigurationSize["$disk"]}" "${machineDisksConfigurationDiskImagePath["$disk"]}"
	
	local -ir machineDiskSizeInBytes="$(stat --format='%s' "${machineDisksConfigurationDiskImagePath["$disk"]}")"
	local -ir dividedMachineDiskSize=$((machineDiskSizeInBytes/512))
	local -ir rehydratedMachineDiskSize=$((dividedMachineDiskSize*512))
	if [ $machineDiskSizeInBytes -ne $rehydratedMachineDiskSize ]; then
		informationMessage FAIL "Machine $machine disk $disk has a size that is not divisible by 512"
		exitError 1
	fi
	
	local -ir machineDiskBlockSizeInBytes=${machineDisksConfigurationBlockSize["$disk"]}
	local -ir dividedBlockSize=$((machineDiskBlockSizeInBytes/512))
	local -ir rehydratedBlockSize=$((dividedBlockSize*512))
	
	if [ $machineDiskBlockSizeInBytes -ne $rehydratedBlockSize ]; then
		informationMessage FAIL "Machine $machine disk $disk has a block size that is not divisible by 512"
		exitError 1
	fi
}
disk_mount_functions+=(disk_mount_createSpareFile)

function disk_mount_createPartitionTable()
{
	# Values match man partx (except for unpartitioned)
	case "$machineHypervisorDiskPartioning" in
		
		unpartitioned)
			return 0
		;;
		
		bsd|solaris|unixware)
			informationMessage FAIL "$machineHypervisorDiskPartioning partitioning is not supported"
			exitError 1
		;;
		
		gpt)
			informationMessage FAIL "GPT partitioning is unsupported at this time"
			exitError 1
		;;
		
		dos)
			:
		;;
	
	esac
	
	# default for start is first unassigned
	local -r start=""
	
	# default for size is to end of disk
	local -r size=","
	
	# id is either 0xXX or E, S, L or X (L is native, S is swap). Other useful types are Linux LVM and Linux RAID
	# sfdisk Partition Types Use sfdisk --list-types to find the known types:-
	
	if [ "${machineDisksConfigurationFilesystemType["$disk"]}" = "swap" ]; then
		local -r id=,S
	else
		local -r id=,L
	fi
	
	# bootable is either * or -
	if [ "${machineDisksConfigurationBootable["$disk"]}" = "yes" ]; then
		local -r bootable=',*'
	else
		local -r bootable=''
	fi
	
	local -r partitionsMap="$cacheMachineArtefactsPath"/"$disk".partition-table.sfdisk.input.txt
	
	# <start>,<size>,<id>,<bootable>,<c,h,s>,<c,h,s>
	cat >"$partitionsMap" <<-EOF
		${start}${size}${id}${bootable}
	EOF
	
	pushd "$cacheMachineDisksPath" 1>/dev/null 2>/dev/null
		
		sfdisk -q "$disk".img 1>/dev/null 2>/dev/null <"$partitionsMap"
		
		# -uS reports in sectors of 512 bytes
		# suppress errors about disk geometry
		sfdisk -d "$disk".img 2>/dev/null | sed -e "s;${disk}.img;${disk};g" >"$cacheMachineArtefactsPath"/"$disk".partition-table.sfdisk.dump.txt
		sfdisk --list "$disk".img 2>/dev/null | sed -e "s;${disk}.img;${disk};g" >"$cacheMachineArtefactsPath"/"$disk".partition-table.sfdisk.report.txt
	popd 1>/dev/null 2>/dev/null
}
disk_mount_functions+=(disk_mount_createPartitionTable)

function disk_mount_image()
{
	# Values match man partx (except for unpartitioned)
	case "$machineHypervisorDiskPartioning" in
		
		unpartitioned)
			# Does nothing
			machineDisksConfigurationPartitionImagePath["$disk"]="${machineDisksConfigurationDiskImagePath["$disk"]}"
			machineDisksConfigurationLoopbackDevice["$disk"]=""
		;;
		
		dos)
			declare -a FUNCTION_RESULT=()
			mounting_mountDisk "${machineDisksConfigurationDiskImagePath["$disk"]}"
			machineDisksConfigurationLoopbackDevice["$disk"]="${FUNCTION_RESULT[0]}"
			machineDisksConfigurationPartitionImagePath["$disk"]="${FUNCTION_RESULT[1]}"
		;;
		
		bsd|solaris|unixware)
			informationMessage FAIL "$machineHypervisorDiskPartioning partitioning is not supported"
			exitError 1
		;;
		
		gpt)
			informationMessage FAIL "GPT partitioning is unsupported at this time"
			exitError 1
		;;
	
	esac
}
disk_mount_functions+=(disk_mount_image)

function disk_mount_createDiskPartitionFilesystem()
{
	if mounting_mountPointIsSpecial; then
		mkswap -f -L "${machineDisksConfigurationVolumeLabel16Bytes["$disk"]}" -U "${machineDisksConfigurationUuid["$disk"]}" "${machineDisksConfigurationPartitionImagePath["$disk"]}" 1>/dev/null 2>/dev/null
		return 0
	fi
	
	declare -a extraOptions=()
	if [ -n "${machineDisksConfigurationOptions["$disk"]}" ]; then
		extraOptions+=(-O)
		extraOptions+=("${machineDisksConfigurationOptions["$disk"]}")
	fi
		
	mkfs."${machineDisksConfigurationFilesystemType["$disk"]}" -F -q -b ${machineDisksConfigurationBlockSize["$disk"]} -L "${machineDisksConfigurationVolumeLabel16Bytes["$disk"]}" -U "${machineDisksConfigurationUuid["$disk"]}" "${extraOptions[@]}" "${machineDisksConfigurationPartitionImagePath["$disk"]}" 1>/dev/null 2>/dev/null
}
disk_mount_functions+=(disk_mount_createDiskPartitionFilesystem)
