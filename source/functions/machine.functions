machines=()
machine_functions=()

function machine_verifyMachineNameIsValidDnsLabel()
{
	local -ir hostnameLength=${#machine}
	if [ $hostnameLength -lt 2 ]; then
		informationMessage FAIL "machine name must be at least 2 characters"
		exit 1
	fi
	
	if [ $hostnameLength -gt 63 ]; then
		informationMessage FAIL "machine name must be no more than 63 characters"
		exit 1
	fi
	
	case "${machine:0:1}" in
		
		[0-9]|-)
			informationMessage FAIL "machine name must not start with a number or hyphen"
			exit 1
		;;
		
		*)
			:
		;;
		
	esac
	
	local convertedHostname
	convertedHostname="$(printf "$machine" | tr -d 'A-Z')"
	if [ ${#convertedHostname} != $hostnameLength ]; then
		informationMessage FAIL "machine name must not contain upper case"
		exit 1
	fi
	
	convertedHostname="$(printf "$machine" | tr -d '.')"
	if [ ${#convertedHostname} != $hostnameLength ]; then
		informationMessage FAIL "machine name must not contain a domain name (ie period)"
		exit 1
	fi
	
	# Delete anything not in abc...
	convertedHostname="$(printf "$machine" | tr -d -C 'abcdefghijklmnopqrstuvwxyz0123456789-')"
	if [ ${#convertedHostname} != $hostnameLength ]; then
		informationMessage FAIL "machine name must consist of a-z, 0-9 or hyphen"
		exit 1
	fi
}
machine_functions+=(machine_verifyMachineNameIsValidDnsLabel)

function machine_prepareMachinePaths()
{
	export configMachinePath="$machinesPath"/"$machine"
	if [ ! -d "$configMachinePath" ]; then
		informationMessage FAIL "Machine $machine missing machine config path $configMachinePath"
		exit 1
	fi
	
	configMachineConfigurationPath="$configMachinePath"/configuration
	if [ ! -f "$configMachineConfigurationPath" ]; then
		informationMessage FAIL "Machine $machine missing machine configuration file $configMachineConfigurationPath"
		exit 1
	fi
	
	configMachinePackagesPath="$configMachinePath"/packages
	if [ ! -f "$configMachinePackagesPath" ]; then
		informationMessage FAIL "Machine $machine missing machine packages file $configMachinePackagesPath"
		exit 1
	fi
	
	configMachineRpmsPath="$configMachinePath"/rpms
	if [ ! -d "$configMachineRpmsPath" ]; then
		informationMessage FAIL "Machine $machine missing machine rpms folder $configMachineRpmsPath"
		exit 1
	fi
	
	configMachineDisksPath="$configMachinePath"/disks
	if [ ! -d "$configMachineDisksPath" ]; then
		informationMessage FAIL "Machine $machine missing machine disks folder $configMachineDisksPath"
		exit 1
	fi
	
	configMachineNicsPath="$configMachinePath"/nics
	if [ ! -d "$configMachineNicsPath" ]; then
		informationMessage FAIL "Machine $machine missing machine nics folder $configMachineNicsPath"
		exit 1
	fi
	
	configMachineGeneratorsPath="$configMachinePath"/generators
	if [ ! -d "$configMachineGeneratorsPath" ]; then
		informationMessage FAIL "Machine $machine missing machine generators folder $configMachineGeneratorsPath"
		exit 1
	fi
	
	configMachineUnderlaysPath="$configMachinePath"/underlays
	if [ ! -d "$configMachineUnderlaysPath" ]; then
		informationMessage FAIL "Machine $machine missing machine underlays folder $configMachineUnderlaysPath"
		exit 1
	fi
	
	configMachineOverlaysPath="$configMachinePath"/overlays
	if [ ! -d "$configMachineOverlaysPath" ]; then
		informationMessage FAIL "Machine $machine missing machine overlays folder $configMachineOverlaysPath"
		exit 1
	fi
	
	configMachineRepositoriesPath="$configMachinePath"/repositories
	if [ ! -d "$configMachineRepositoriesPath" ]; then
		informationMessage FAIL "Machine $machine missing repositories folder $configMachineRepositoriesPath"
		exit 1
	fi
	
	cacheMachinePath="$cacheMachineGroupMachinesPath"/"$machine"
	mkdir -m 0755 -p "$cacheMachinePath"
	
	cacheMachineOverlaysGeneratedPath="$cacheMachinePath"/overlays
	rm -rf "$cacheMachineOverlaysGeneratedPath"
	mkdir -m 0755 -p "$cacheMachineOverlaysGeneratedPath"
	
	cacheMachineDisksPath="$cacheMachinePath"/disks
	mkdir -m 0755 -p "$cacheMachineDisksPath"
	
	export cacheMachineDisksMountsPath="$cacheMachinePath"/disks-mountpoint
	rm -rf "$cacheMachineDisksMountsPath"
	mkdir -m 0755 -p "$cacheMachineDisksMountsPath"
	
	cacheMachineArtefactsPath="$cacheMachinePath"/artefacts
	mkdir -m 0755 -p "$cacheMachineArtefactsPath"
}
machine_functions+=(machine_prepareMachinePaths)

function machine_cleanUpMachinesCache()
{
	pushd "$cacheMachineGroupMachinesPath" 1>/dev/null 2>/dev/null
		local cachedMachine
		for cachedMachine in *
		do
			if [ ! -d "$cachedMachine" ]; then
				continue
			fi
			local -i found=0
			local knownMachine
			for knownMachine in "${knownMachines[@]}"
			do
				if [ "$knownMachine" = "$cachedMachine" ]; then
					found=1
					break
				fi
			done
			if [ $found -eq 0 ]; then
				rm -rf "$cachedMachine"
			fi
		done
	popd 1>/dev/null 2>/dev/null
}
machine_functions+=(machine_cleanUpMachinesCache)

function machine_defaultMachineConfiguration()
{
	configuration_sourceDefaultConfiguration "machine"
}
machine_functions+=(machine_defaultMachineConfiguration)

function machine_sourceMachineConfiguration()
{
	source "$configMachineConfigurationPath"
}
machine_functions+=(machine_sourceMachineConfiguration)

function machine_validateMachineConfiguration()
{
	validateHypervisorNameAndOutputFormat
}
machine_functions+=(machine_validateMachineConfiguration)

machinePackageNames=()
function machine_readMachinePackages()
{
	mapfile -t machinePackageNames < <(configuration_readPackageNames "$configMachinePackagesPath")
}
machine_functions+=(machine_readMachinePackages)

machineRpmFiles=()
function machine_readMachineRpmFiles()
{
	mapfile -t machineRpmFiles < <(configuration_readRpmFiles "$configMachineRpmsPath")
}
machine_functions+=(machine_readMachineRpmFiles)

machineNics=()
function machine_readMachineNicNames()
{
	mapfile -t machineNics < <(configuration_readNames "$configMachineNicsPath" "nic")
}
machine_functions+=(machine_readMachineNicNames)

machineDisks=()
function machine_readMachineDiskNames()
{
	mapfile -t machineDisks < <(configuration_readNames "$configMachineDisksPath" "disk")
}
machine_functions+=(machine_readMachineDiskNames)

function machine_configureNics()
{
	local nic
	for nic in "${machineNics[@]}"
	do
		local nicConfigureFunction
		for nicConfigureFunction in "${nicConfigureFunctions[@]}"
		do
			informationMessage INFO "${tab}${tab}${tab}${disk} ${nicConfigureFunction}"
			$nicConfigureFunction
		done
	done
}
machine_functions+=(machine_configureNics)

function machine_configureDisks()
{
	local disk
	for disk in "${machineDisks[@]}"
	do
		local disk_configure_function
		for disk_configure_function in "${disk_configure_functions[@]}"
		do
			informationMessage INFO "${tab}${tab}${tab}${disk} ${disk_configure_function}"
			$disk_configure_function
		done
	done
}
machine_functions+=(machine_configureDisks)

function machine_mountDisks()
{
	local disk
	for disk in "${machineDisks[@]}"
	do
		local disk_mount_function
		for disk_mount_function in "${disk_mount_functions[@]}"
		do
			informationMessage INFO "${tab}${tab}${tab}${disk} ${disk_mount_function}"
			$disk_mount_function
		done
	done
}
machine_functions+=(machine_mountDisks)

machineDiskMountPointsInForwardDiskOrder=()
machineDiskMountPointsInReverseDiskOrder=()
function machine_recordSortedDiskMountPoints()
{
	machineDiskMountPointsInForwardDiskOrder=()
	
	local mountPoint
	local disk
	while IFS=' ' read -r mountPoint disk
	do
		machineDiskMountPointsInForwardDiskOrder+=("$disk")
	done < <(sortDiskMountPointsInForwardOrder)
	
	machineDiskMountPointsInReverseDiskOrder=()
	local -i index
	for (( index=$((${#machineDiskMountPointsInForwardDiskOrder[*]}-1)); index>=0; index-- ))
	do
		disk=${machineDiskMountPointsInForwardDiskOrder[$index]}
		machineDiskMountPointsInReverseDiskOrder+=("$disk")
	done
}
machine_functions+=(machine_recordSortedDiskMountPoints)

function machine_mountDiskPartitions()
{
	local disk
	for disk in "${machineDiskMountPointsInForwardDiskOrder[@]}"
	do
		local disk_partitionMount_function
		for disk_partitionMount_function in "${disk_partitionMount_functions[@]}"
		do
			if mountPointIsSpecial; then
				informationMessage INFO "${tab}${tab}${tab}${disk} (ignored)"
				continue
			fi
			
			informationMessage INFO "${tab}${tab}${tab}${disk} ${diskMountFuncton}"
			$disk_partitionMount_function
		done
	done
}
machine_functions+=(machine_mountDiskPartitions)

function machine_installUnderlays()
{
	installFilesystem "$configMachineGroupUnderlaysPath"
	installFilesystem "$configMachineUnderlaysPath"
}
machine_functions+=(machine_installUnderlays)

function machine_installRpmsFromYum()
{
	local yum_function
	for yum_function in "${yum_functions[@]}"
	do
		$yum_function
	done
}
machine_functions+=(machine_installRpmsFromYum)

function machine_sourceMachineGenerators()
{
	# Relies on cacheMachineOverlaysGeneratedPath
	generators_source "machine" "$configMachineGeneratorsPath"
}
machine_functions+=(machine_sourceMachineGenerators)

function machine_installOverlays()
{
	installFilesystem "$configMachineGroupOverlaysPath"
	installFilesystem "$cacheMachineGroupOverlaysGeneratedPath"
	installFilesystem "$configMachineOverlaysPath"
	installFilesystem "$cacheMachineOverlaysGeneratedPath"
}
machine_functions+=(machine_installOverlays)

function machine_determineRootDiskUuid()
{
	machineRootDiskFilesystemUuid=""
	local disk
	for disk in "${machineDisks[@]}"
	do
		if [ "${machineDisksConfigurationMountPoint["$disk"]}" = "/" ]; then
			machineRootDiskFilesystemUuid="${machineDisksConfigurationUuid["$disk"]}"
			break
		fi
	done
	
	if [ -z "$machineRootDiskFilesystemUuid" ]; then
		informationMessage FAIL "Could not find machine root disk UUID (do you have a root disk)?"
		exitError 1
	fi
}
machine_functions+=(machine_determineRootDiskUuid)

function machine_determinKernelAdditionalOptions()
{
	local machineKernelOptions="root=UUID=${machineRootDiskFilesystemUuid}"
	if [ -n "$machineKernelAdditionalOptions" ]; then
		machineKernelOptions="${machineKernelOptions} ${machineKernelAdditionalOptions}"
	fi
}
machine_functions+=(machine_determinKernelAdditionalOptions)

function machine_determineKernelAndInitRd()
{
	pushd "$cacheMachineDisksMountsPath" 1>/dev/null 2>/dev/null
		
		machineKernelAbsolutePath=""
		local file
		for file in boot/vmlinuz-*.x86_64
		do
			if [ -f "$file" ]; then
				machineKernelAbsolutePath="/${file}"
				break
			fi
		done
		
		if [ -z "$machineKernelAbsolutePath" ]; then
			informationMessage FAIL "Could not find kernel in /boot"
			exitError 1
		fi
		
		machineInitramfsAbsolutePath=""
		local file
		for file in boot/initramfs-*.img
		do
			if [ -f "$file" ]; then
				machineInitramfsAbsolutePath="/${file}"
				break
			fi
		done
		
		if [ -z "$machineInitramfsAbsolutePath" ]; then
			informationMessage FAIL "Could not find initramfs in /boot"
			exitError 1
		fi
	
	popd 1>/dev/null 2>/dev/null
	
	machineKernelFileName="$(purebash_basename "$machineKernelAbsolutePath")"
	machineInitramfsFileName="$(purebash_basename "$machineInitramfsAbsolutePath")"
}
machine_functions+=(machine_determineKernelAndInitRd)

function machine_copyKernelAndInitRdForUnpartitioned()
{
	if [ "$machineHypervisorDiskFormat" != "unpartitioned" ]; then
		return 0
	fi
	
	cp "${cacheMachineDisksMountsPath}${machineKernelAbsolutePath}" "$cacheMachineArtefactsPath"/"$machineKernelFileName"
	ln -s "$machineKernelFileName" "$cacheMachineArtefactsPath"/vmlinuz
	
	cp "${cacheMachineDisksMountsPath}${machineInitramfsAbsolutePath}" "$cacheMachineArtefactsPath"/"$machineInitramfsFileName"
	ln -s "$machineInitramfsFileName" "$cacheMachineArtefactsPath"/initramfs.img
}
machine_functions+=(machine_copyKernelAndInitRdForUnpartitioned)

function machine_installExtLinux()
{
	# Values match man partx (except for unpartitioned)
	case "$machineHypervisorDiskPartioning" in
		
		unpartitioned)
			return 0
		;;
		
		bsd|solaris|unixware)
			informationMessage FAIL "$machineHypervisorDiskPartioning partitioning is not supported for extlinux"
			exitError 1
		;;
		
		gpt)
			informationMessage FAIL "GPT partitioning is unsupported at this time for extlinux"
			exitError 1
		;;
		
		dos)
			:
		;;
	
	esac
	
	local disk
	for disk in "$machineDisks"
	do
		if [ "${machineDisksConfigurationBootable["$disk"]}" = "yes" ]; then
			local extlinux_function
			for extlinux_function in "${extlinux_functions[@]}"
			do
				# installExtlinux_determineInstallPath uses $disk
				$extlinux_function
			done
		fi
	done
}
machine_functions+=(machine_installExtLinux)

function machine_recordHashesOfAllFiles()
{
	recordHashes "${cacheMachineDisksMountsPath}" "/" "$cacheMachineArtefactsPath"/files-installed.report.txt
}
machine_functions+=(machine_recordHashesOfAllFiles)

function machine_unmountDiskPartitions()
{
	local disk
	for disk in "${machineDiskMountPointsInReverseDiskOrder[@]}"
	do
		if mountPointIsSpecial; then
			informationMessage INFO "${tab}${tab}${tab}${disk} (ignored)"
			continue
		fi
		
		local disk_partitionUnmount_function
		for disk_partitionUnmount_function in "${disk_partitionUnmount_functions[@]}"
		do
			informationMessage INFO "${tab}${tab}${tab}${disk} ${disk_partitionUnmount_function}"
			$disk_partitionUnmount_function
		done
	done
}
machine_functions+=(machine_unmountDiskPartitions)

function machine_unmountDisks()
{
	local disk
	for disk in "${machineDiskMountPointsInReverseDiskOrder[@]}"
	do
		local disk_unmount_function
		for disk_unmount_function in "${disk_unmount_functions[@]}"
		do
			informationMessage INFO "${tab}${tab}${tab}${disk} ${disk_unmount_function}"
			$disk_unmount_function
		done
	done
}
machine_functions+=(machine_unmountDisks)

function machine_createMetadata()
{
	if [ "$machineHypervisorMetadataOutputFormat" = "none" ]; then
		return 0
	fi
	
	hypervisorMetadata_${machineHypervisorName}
}
machine_functions+=(machine_createMetadata)
