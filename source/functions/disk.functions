diskCreateFunctions=()

function defaultDiskImageConfiguration()
{
	machineDiskSize=256M
	machineDiskMountPoint=/
	machineDiskFilesystemType=ext4
	machineDiskBlockSize=4096
	machineDiskVolumeLabel16Bytes="$disk"
	machineDiskUuid=48c2b730-62a5-4b06-99be-85c0ea4d53dd
	machineDiskOptions=uninit_bg,extent,has_journal,resize_inode,sparse_super
	machineDiskMountOptions=defaults
	machineDiskDumpOptions=0
	machineDiskFsckOptions=0
}
diskCreateFunctions+=(defaultDiskImageConfiguration)

function sourceDiskImageConfiguration()
{
	source "$configMachineDisksPath"/"$disk".disk
	
	machineDiskImagePath="$cacheMachineDisksPath"/"$disk".img
	
	machineDiskImageMountPath="$cacheMachineDisksMountsPath${machineDiskMountPoint}"
}
diskCreateFunctions+=(sourceDiskImageConfiguration)

function verifyDiskImageConfiguration()
{
	if [ ${#machineDiskVolumeLabel16Bytes} -gt 16 ]; then
		informationMessage FAIL "Machine $machine has a disk $disk with a label greater than 16 characters (defaults to disk name) in parameters or disk folder"
		exit 1
	fi
	
	case "$machineDiskFilesystemType" in
		
		ext[2-4])
			:
		;;
		
		swap)
			:
		;;
		
		*)
			informationMessage FAIL "Machine $machine has a disk $disk with an unknown filesystem type $machineDiskFilesystemType"
			exit 1
		;;
	
	esac
}
diskCreateFunctions+=(verifyDiskImageConfiguration)

function captureInABashDictionaryMachineDiskConfigurationForMountingAndUnmounting()
{
	machineDisksConfigurationFilesystemType["$disk"]="$machineDiskFilesystemType"
	machineDisksConfigurationMountPoint["$disk"]="$machineDiskMountPoint"
	machineDisksConfigurationImagePath["$disk"]="$machineDiskImagePath"
	machineDisksConfigurationImageMountPath["$disk"]="$machineDiskImageMountPath"
	machineDisksConfigurationUuid["$disk"]="$machineDiskUuid"
	machineDisksConfigurationMountOptions["$disk"]="$machineDiskMountOptions"
	machineDisksConfigurationDumpOptions["$disk"]="$machineDiskDumpOptions"
	machineDisksConfigurationFsckOptions["$disk"]="$machineDiskFsckOptions"
}
diskCreateFunctions+=(captureInABashDictionaryMachineDiskConfigurationForMountingAndUnmounting)

function createDiskImageSpareFile()
{
	rm -rf "$machineDiskImagePath"
	truncate -s "$machineDiskSize" "$machineDiskImagePath"
}
diskCreateFunctions+=(createDiskImageSpareFile)

function createDiskImageFilesystem()
{
	if mountPointIsSpecial; then
		mkswap -f -L "$machineDiskVolumeLabel16Bytes" -U "$machineDiskUuid" "$machineDiskImagePath" 1>/dev/null 2>/dev/null
		return 0
	fi
	
	mkfs."$machineDiskFilesystemType" -F -q -b $machineDiskBlockSize -L "$machineDiskVolumeLabel16Bytes" -U "$machineDiskUuid" -O "$machineDiskOptions" "$machineDiskImagePath"
}
diskCreateFunctions+=(createDiskImageFilesystem)

function sortDiskMountPoints()
{
	(
		local disk
		for disk in "${machineDisks[@]}"
		do
			echo "${machineDisksConfigurationMountPoint["$disk"]} ${disk}"
		done
	) | sort --ignore-nonprinting
}

function reverseSortDiskMountPoints()
{
	(
		local disk
		for disk in "${machineDisks[@]}"
		do
			echo "${machineDisksConfigurationMountPoint["$disk"]} ${disk}"
		done
	) | sort --reverse --ignore-nonprinting
}

function mountPointIsSpecial()
{
	local -r mountPoint="${machineDisksConfigurationMountPoint["$disk"]}"
	if [ "${mountPoint:0:1}" != '/' ]; then
		return 0
	fi
	return 1
}

# Abstracted to support Mac OS X mounting in the future: http://nicksegers.com/mounting-to-loopback-in-osx/
function mountLoopbackDiskImage()
{
	local -r filesystemType="$1"
	local -r imagePath="$2"
	local -r mountPath="$3"
	
	if [ "$(uname)" = "Darwin" ]; then
		#local -r devicePath="$(hdiutil attach -imagekey diskimage-class=CRawDiskImage -readwrite -noverify -noautopen -noautofsck -mountpoint "$mountPath" -nomount "$imagePath")"
		#diskutil mount "$devicePath"
		return 0
	fi
	
	mount -o loop -t "$filesystemType" "$imagePath" "$mountPath"
	registerLoopbackMountPointToRemoveOnExit "$mountPath"
}

# Abstracted to support Mac OS X mounting in the future: http://nicksegers.com/mounting-to-loopback-in-osx/
function mountBind()
{
	local -r mountPath="$1"

	if [ "$(uname)" = "Darwin" ]; then
		return 0
	fi

	mount -o bind /dev "$mountPath"
	registerBindMountPointToRemoveOnExit "$mountPath"
}

function unmountBind()
{
	local -r mountPath="$1"
	
	if [ "$(uname)" = "Darwin" ]; then
		# yum does not exist in brew; installing via source has problems (msgfmt, broken Makefile, broken install utility; Python versioning)
		return 0
	fi
	
	unregisterLastBindMountPointToRemoveOnExit "$mountPath"
	umount "$mountPath"
}

function unmountLoopback()
{
	local -r mountPath="$1"

	if [ "$(uname)" = "Darwin" ]; then
		# yum does not exist in brew; installing via source has problems (msgfmt, broken Makefile, broken install utility; Python versioning)
		return 0
	fi
	
	unregisterLastLoopbackMountPointToRemoveOnExit "$mountPath"
	umount "$mountPath"
}

loopbackMountPointsToRemoveOnExit=()
function registerLoopbackMountPointToRemoveOnExit()
{
	local loopbackMountPointToRemoveOnExit="$1"
	loopbackMountPointsToRemoveOnExit+=("$loopbackMountPointToRemoveOnExit")
}

function unregisterLastLoopbackMountPointToRemoveOnExit()
{
	local loopbackMountPointToRemoveOnExit="$1"
	unset loopbackMountPointsToRemoveOnExit[$((${#loopbackMountPointsToRemoveOnExit[*]}-1))]
}

function removeLoopbackMountPointsOnExit()
{
	local loopbackMountPointToRemoveOnExit
	for loopbackMountPointToRemoveOnExit in "${loopbackMountPointsToRemoveOnExit[@]}"
	do
		unmountLoopback "$loopbackMountPointToRemoveOnExit"
	done
}

bindMountPointsToRemoveOnExit=()
function registerBindMountPointToRemoveOnExit()
{
	local bindMountPointToRemoveOnExit="$1"
	bindMountPointsToRemoveOnExit+=("$bindMountPointToRemoveOnExit")
}

function unregisterLastBindMountPointToRemoveOnExit()
{
	local bindMountPointToRemoveOnExit="$1"
	unset bindMountPointsToRemoveOnExit[$((${#bindMountPointsToRemoveOnExit[*]}-1))]
}

function removeBindMountPointsOnExit()
{
	local bindMountPointToRemoveOnExit
	for bindMountPointToRemoveOnExit in "${bindMountPointsToRemoveOnExit[@]}"
	do
		unmountBind "$bindMountPointToRemoveOnExit"
	done
}

function createDiskImageMountpoint()
{
	mkdir -m 0755 -p "${machineDisksConfigurationImageMountPath["$disk"]}"
}
diskMountFunctions+=(createDiskImageMountpoint)

function mountDiskImage()
{
	mountLoopbackDiskImage "${machineDisksConfigurationFilesystemType["$disk"]}" "${machineDisksConfigurationImagePath["$disk"]}" "${machineDisksConfigurationImageMountPath["$disk"]}"
}
diskMountFunctions+=(mountDiskImage)


diskUnmountFunctions=()

function syncDiskImage()
{
	sync
}
diskUnmountFunctions+=(syncDiskImage)

function shrinkDiskImage()
{
	echo "FIXME: Disk resize for ext2/3/4 but only if permitted"
	#resize2fs -P /dev/disk/by-uuid/"${machineDisksConfigurationUuid["$disk"]}"
	# -M gives minum size
	#resize2fs -M
	#truncate -s <<minimumSize>>
}
diskUnmountFunctions+=(shrinkDiskImage)

function unmountDiskImage()
{
	unmountLoopback "${machineDisksConfigurationImageMountPath["$disk"]}" || true
}
diskUnmountFunctions+=(unmountDiskImage)


