diskCreateFunctions=()

function defaultDiskImageConfiguration()
{
	source "$configDefaultsPath"/disk.default.configuration
}
diskCreateFunctions+=(defaultDiskImageConfiguration)

function sourceDiskImageConfiguration()
{
	source "$configMachineDisksPath"/"$disk".disk
	
	machineDiskImagePath="$cacheMachineDisksPath"/"$disk".img
	
	machineDiskImageMountPath="${cacheMachineDisksMountsPath}${machineDiskMountPoint}"
}
diskCreateFunctions+=(sourceDiskImageConfiguration)

function verifyDiskImageConfiguration()
{
	if [ ${#machineDiskVolumeLabel16Bytes} -gt 16 ]; then
		informationMessage FAIL "Machine $machine has a disk $disk with a label greater than 16 characters (defaults to disk name) in parameters or disk folder"
		exit 1
	fi
	
	case "$machineDiskFilesystemType" in
		
		ext[2-4])
			:
		;;
		
		btrfs)
			:
		;;
		
		xfs)
			:
		;;
		
		swap)
			:
		;;
		
		*)
			informationMessage FAIL "Machine $machine has a disk $disk with an unknown filesystem type $machineDiskFilesystemType"
			exit 1
		;;
	
	esac
}
diskCreateFunctions+=(verifyDiskImageConfiguration)

function captureInABashDictionaryMachineDiskConfigurationForMountingAndUnmounting()
{
	machineDisksConfigurationFilesystemType["$disk"]="$machineDiskFilesystemType"
	machineDisksConfigurationBlockSize["$disk"]="$machineDiskBlockSize"
	machineDisksConfigurationMountPoint["$disk"]="$machineDiskMountPoint"
	machineDisksConfigurationDiskImagePath["$disk"]="$machineDiskImagePath"
	machineDisksConfigurationImageMountPath["$disk"]="$machineDiskImageMountPath"
	machineDisksConfigurationUuid["$disk"]="$machineDiskUuid"
	machineDisksConfigurationMountOptions["$disk"]="$machineDiskMountOptions"
	machineDisksConfigurationDumpOptions["$disk"]="$machineDiskDumpOptions"
	machineDisksConfigurationFsckOptions["$disk"]="$machineDiskFsckOptions"
	machineDisksConfigurationShrinkDisk["$disk"]="$machineDiskShrink"
	machineDisksConfigurationBootable["$disk"]="$machineDiskBootable"
	machineDisksConfigurationPartitionImagePath["$disk"]=""
}
diskCreateFunctions+=(captureInABashDictionaryMachineDiskConfigurationForMountingAndUnmounting)

function createDiskImageSpareFile()
{
	rm -rf "$machineDiskImagePath"
	truncate -s "$machineDiskSize" "$machineDiskImagePath"
	
	machineDiskSize="$(stat --format='%s' "$machineDiskImagePath")"
	local -ir dividedMachineDiskSize=$((machineDiskSize/512))
	local -ir rehydratedMachineDiskSize=$((dividedMachineDiskSize*512))
	if [ $machineDiskSize -ne $rehydratedMachineDiskSize ]; then
		informationMessage FAIL "Machine $machine disk $disk has a size that is not divisible by 512"
		exitError 1
	fi
	
	local -ir dividedBlockSize=$((machineDiskBlockSize/512))
	local -ir rehydratedBlockSize=$((dividedBlockSize*512))
	
	if [ $machineDiskBlockSize -ne $rehydratedBlockSize ]; then
		informationMessage FAIL "Machine $machine disk $disk has a block size that is not divisible by 512"
		exitError 1
	fi
}
diskCreateFunctions+=(createDiskImageSpareFile)

function createDiskImagePartitionTable()
{
	# Values match man partx (except for unpartitioned)
	case "$machineHypervisorDiskPartioning" in
		
		unpartitioned)
			return 0
		;;
		
		bsd|solaris|unixware)
			informationMessage FAIL "$machineHypervisorDiskPartioning partitioning is not supported"
			exitError 1
		;;
		
		gpt)
			informationMessage FAIL "GPT partitioning is unsupported at this time"
			exitError 1
		;;
		
		dos)
			:
		;;
	
	esac
	
	# default for start is first unassigned
	local -r start=""
	
	# default for size is to end of disk
	local -r size=","
	
	# id is either 0xXX or E, S, L or X (L is native, S is swap)
	if [ "$machineDiskFilesystemType" = "swap" ]; then
		local -r id=,S
	else
		local -r id=,L
	fi
	
	# bootable is either * or -
	if [ "$machineDiskBootable" = "yes" ]; then
		local -r bootable=',*'
	else
		local -r bootable=''
	fi
	
	local -r partitionsMap="$cacheMachineArtefactsPath"/"$disk".partition-table.sfdisk.input.txt
	
	# <start>,<size>,<id>,<bootable>,<c,h,s>,<c,h,s>
	cat >"$partitionsMap" <<-EOF
		${start}${size}${id}${bootable}
	EOF
	
	pushd "$cacheMachineDisksPath" 1>/dev/null 2>/dev/null
		
		sfdisk -q "$disk".img 1>/dev/null 2>/dev/null <"$partitionsMap"
		
		# -uS reports in sectors of 512 bytes
		# suppress errors about disk geometry
		sfdisk -d "$disk".img 2>/dev/null | sed -e "s;${disk}.img;${disk};g" >"$cacheMachineArtefactsPath"/"$disk".partition-table.sfdisk.dump.txt
		sfdisk --list "$disk".img 2>/dev/null | sed -e "s;${disk}.img;${disk};g" >"$cacheMachineArtefactsPath"/"$disk".partition-table.sfdisk.report.txt
	popd 1>/dev/null 2>/dev/null
}
diskCreateFunctions+=(createDiskImagePartitionTable)

function mountDiskImage()
{
	# Values match man partx (except for unpartitioned)
	case "$machineHypervisorDiskPartioning" in
		
		unpartitioned)
			# Does nothing
			machineDisksConfigurationPartitionImagePath["$disk"]="${machineDisksConfigurationDiskImagePath["$disk"]}"
		;;
		
		dos)
			machineDisksConfigurationPartitionImagePath["$disk"]="$(mountDisk "${machineDisksConfigurationDiskImagePath["$disk"]}")"
		;;
		
		bsd|solaris|unixware)
			informationMessage FAIL "$machineHypervisorDiskPartioning partitioning is not supported"
			exitError 1
		;;
		
		gpt)
			informationMessage FAIL "GPT partitioning is unsupported at this time"
			exitError 1
		;;
	
	esac
}
diskMountFunctions+=(mountDiskImage)

function createDiskPartitionMountpoint()
{
	mkdir -m 0755 -p "${machineDisksConfigurationImageMountPath["$disk"]}"
}
diskMountFunctions+=(createDiskPartitionMountpoint)

function createDiskPartitionFilesystem()
{
	if mountPointIsSpecial; then
		mkswap -f -L "$machineDiskVolumeLabel16Bytes" -U "$machineDiskUuid" "${machineDisksConfigurationPartitionImagePath["$disk"]}" 1>/dev/null 2>/dev/null
		return 0
	fi
	
	mkfs."$machineDiskFilesystemType" -F -q -b $machineDiskBlockSize -L "$machineDiskVolumeLabel16Bytes" -U "$machineDiskUuid" -O "$machineDiskOptions" "${machineDisksConfigurationPartitionImagePath["$disk"]}"
}
diskMountFunctions+=(createDiskPartitionFilesystem)

function mountDiskPartition()
{
	mountLoopback "${machineDisksConfigurationFilesystemType["$disk"]}" "${machineDisksConfigurationPartitionImagePath["$disk"]}" "${machineDisksConfigurationImageMountPath["$disk"]}"
}
diskMountFunctions+=(mountDiskPartition)


diskUnmountFunctions=()

function unmountSyncDisk()
{
	# Does not flush ext3 journal
	sync
}
diskUnmountFunctions+=(unmountSyncDisk)

function unmountDiskPartition()
{
	unmountLoopback "${machineDisksConfigurationImageMountPath["$disk"]}" || true
}
diskUnmountFunctions+=(unmountDiskPartition)

function unmountOptimiseDisk()
{
	case "${machineDisksConfigurationFilesystemType["$disk"]}" in
	
		ext2|ext3|ext4)
			e2fsck -D -f "${machineDisksConfigurationPartitionImagePath["$disk"]}" 1>/dev/null 2>/dev/null
			tune2fs -f -c 0 -C 0 -i 36m -M "${machineDisksConfigurationPartitionImagePath["$disk"]}" -u 0 -g 0 "${machineDisksConfigurationPartitionImagePath["$disk"]}"
		;;
	
		*)
			return 0
		;;
	esac
}
diskUnmountFunctions+=(unmountOptimiseDisk)

function shrinkDiskImage()
{
	if [ "${machineDisksConfigurationShrinkDisk["$disk"]}" != "yes" ]; then
		return 0
	fi
	
	# Values match man partx (except for unpartitioned)
	case "$machineHypervisorDiskPartioning" in
		
		unpartitioned)
			:
		;;
		
		bsd|solaris|unixware)
			informationMessage FAIL "$machineHypervisorDiskPartioning partitioning is not supported for extlinux"
			exitError 1
		;;
		
		gpt)
			informationMessage FAIL "GPT partitioning is unsupported at this time for extlinux"
			exitError 1
		;;
		
		dos)
			informationMessage WARN "Dish shrinking is not currently possible when using DOS partition tables"
			return 0
		;;
	
	esac
	
	case "${machineDisksConfigurationFilesystemType["$disk"]}" in
		
		ext2|ext3|ext4)
			:
		;;
		
		*)
			return 0
		;;
	esac
	
	machineDiskBlockSize=${machineDisksConfigurationBlockSize["$disk"]}
	
	local -ir minimumSize="$(resize2fs -P "${machineDisksConfigurationPartitionImagePath["$disk"]}" 2>/dev/null | awk '{print $7}')"
	resize2fs -M "${machineDisksConfigurationPartitionImagePath["$disk"]}" 2>/dev/null
	
	local -ir shrinkSizeInBytes=$((minimumSize*machineDiskBlockSize))
	truncate -s $shrinkSizeInBytes "${machineDisksConfigurationDiskImagePath["$disk"]}"
}
diskUnmountFunctions+=(shrinkDiskImage)

function unmountDiskImage()
{
	# Values match man partx (except for unpartitioned)
	case "$machineHypervisorDiskPartioning" in
		
		unpartitioned)
			# Does nothing
			:
		;;
		
		dos)
			# unmountDisk takes the original disk image path, not the loopback device created, unlike unmountLoopback
			unmountDisk "${machineDisksConfigurationDiskImagePath["$disk"]}"
		;;
		
		bsd|solaris|unixware)
			informationMessage FAIL "$machineHypervisorDiskPartioning partitioning is not supported"
			exitError 1
		;;
		
		gpt)
			informationMessage FAIL "GPT partitioning is unsupported at this time"
			exitError 1
		;;
	
	esac
}
diskUnmountFunctions+=(unmountDiskImage)

function convertDiskImage()
{
	convertDiskImage_${machineHypervisorDiskExtension}
}
diskUnmountFunctions+=(convertDiskImage)
