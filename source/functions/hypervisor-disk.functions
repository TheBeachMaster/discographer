function pathToOutputFile()
{
	local -r extension="$1"
	local -r inputFile="${machineDisksConfigurationImagePath["$disk"]}"
	local -r withoutExtension="${inputFile%%.img}"
	local -r fileName="$(purebash_basename "$withoutExtension")"
	echo -n "$cacheMachineArtefactsPath"/"$fileName"."$extension"
}

function convertDiskImageUsingQemuImg()
{
	local -r extension="$1"
	local -r format="$2"
	shift 2
	
	local -r inputFile="${machineDisksConfigurationImagePath["$disk"]}"
	local -r outputFile="$(pathToOutputFile "$extension")"

	# -c is qcow compression
	qemu-img convert -q -f raw -O "$extension" "$@" "$inputFile" "$outputFile"
	rm -rf "$inputFile"

	machineDisksConfigurationImagePath["$disk"]="$outputFile"
}

function convertDiskImage_ovf2()
{
	convertDiskImage_vmware
}

function convertDiskImage_raw()
{
	local -r inputFile="${machineDisksConfigurationImagePath["$disk"]}"
	local -r outputFile="$(pathToOutputFile "img")"
	
	# Hard link; copy if that fails (eg on different disks)
	ln "$inputFile" "$outputFile" 2>/dev/null || cp "$inputFile" "$outputFile"
	rm -rf "$inputFile"
	
	machineDisksConfigurationImagePath["$disk"]="$outputFile"
}

function convertDiskImage_kvm()
{
	convertDiskImageUsingQemuImg qcow2 qcow2 -c -o compat=1.1,preallocation=off,cluster_size=512
}

function convertDiskImage_vmware()
{
	convertDiskImageUsingQemuImg vmdk vmdk
}

function convertDiskImage_virtualbox()
{
	convertDiskImageUsingQemuImg vdi vdi
	# We also force the UUID of the VDI disk to match the file system UUID.
	VBoxManage internalcommands sethduuid "$cacheMachineArtefactsPath"/"$disk".vdi "${machineDisksConfigurationUuid["$disk"]}"
}

function convertDiskImage_parallels()
{
	convertDiskImageUsingQemuImg hdd parallels
}