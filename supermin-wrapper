#!/usr/bin/env bash
set +o allexport -o braceexpand +o emacs -o errexit +o errtrace +o functrace +o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword +o monitor +o noclobber +o noexec +o noglob +o nolog +o notify +o nounset +o onecmd +o physical +o pipefail +o posix +o verbose +o vi +o xtrace;unset BASH_ENV;unset BASH_XTRACEFD;unset CDPATH;unset ENV;unset FCEDIT;unset FIGNORE;unset FUNCNEST;unset GLOBIGNORE;unset HISTCONTROL;unset HISTFILE;unset HISTFILESIZE;unset HISTIGNORE;unset HISTSIZE;unset HISTTIMEFORMAT;unset HOSTFILE;unset IGNOREEOF;unset INPUTRC;unset MAIL;unset MAILCHECK;unset MAILPATH;unset TMOUT;umask 022

function ensureWeAreRunningBash4()
{
	if [ ${BASH_VERSINFO[0]} != "4" ]; then
		exitError "$ourName: You are not running bash 4."
	fi
}

function informationMessage()
{
	local messageKind="$1"
	local message="$2"
	
	case "$messageKind" in
		
		WARN|FAIL)
			echo "$ourName: $messageKind: $message"
		;;
		
		*)
			if [ "$optionVerbose" = "yes" ]; then
				echo "$ourName: $messageKind: $message"
			fi
		;;
	
	esac
}

function initialiseTraps()
{
	addNextTrapHandler removeFilesOnExit
}

function runOnTrap()
{
	local trapHandler
	for trapHandler in "${trapHandlers[@]}"
	do
		$trapHandler
	done
}

function addNextTrapHandler()
{
	local trapHandler="$1"
	trap runOnTrap 0 HUP INT QUIT ILL ABRT FPE SEGV PIPE TERM EXIT
	trapHandlers+=("$trapHandler")
}

function removeLastTrapHandler()
{
	unset trapHandlers[$((${#trapHandlers[*]}-1))]
}

function removeFilesOnExit()
{
	rm -rf -- "${filesToRemoveOnExit[@]}"
}

function addFileToRemoveOnExit()
{
	local -r fileToRemove="$1"
	filesToRemoveOnExit+=("$fileToRemove")
}

function temporaryFileToRemoveOnExit()
{
	TMP_FILE="$(mktemp -t "$ourName".XXXXXXXXXXXX)"
	filesToRemoveOnExit+=("$TMP_FILE")
}

function temporaryFolderToRemoveOnExit()
{
	TMP_FILE="$(mktemp -t -d "$ourName".XXXXXXXXXXXX)"
	filesToRemoveOnExit+=("$TMP_FILE")
}

# The purpose of these functions is to provide internal implementations of logic we can't be 100%
# sure of exists in the environment or is implemented as we would like for critical pieces of code.
# Such a critical piece is code executed before and during command line arg parsing (eg exitError)
function purebash_dirname()
{
	local -r converted="${1%/*}"
	if [ "$converted" = "$1" ]; then
		echo "."
	else
		echo "$converted"
	fi
}

function purebash_basename()
{
	echo "${1##*/}"
}

# Original solution used heredocuments, which were then sourced; this does not work when /tmp is readonly,
# even if TMPDIR is set elsewhere, as debian / ubuntu bash uses a hardcoded /tmp
# http://stackoverflow.com/questions/1609423/using-sed-to-expand-environment-variables-inside-files
function createSedScriptOfEnvironmentVariableSubstitutions()
{
	env | sed 's/[\%]/\\&/g;s/\([^=]*\)=\(.*\)/s%${\1}%\2%g/'
}

function templateFile()
{
	set +e
	cat "$1" | sed -f <(createSedScriptOfEnvironmentVariableSubstitutions)
	set -e
}

function setDebugging()
{
	# is set -x on?
	if [[ "$-" == *x* ]]; then
		export SUPERMIN_BASH_DEBUGGING="yes"
	elif [ ! -z "$SUPERMIN_BASH_DEBUGGING" ]; then
		if [ "$SUPERMIN_BASH_DEBUGGING" = "yes" ]; then
			set -x
		fi
	fi
}

function findOurNameAndPath()
{
	readonly ourName="$(purebash_basename "$0")"
	pushd "$(purebash_dirname "$0")" >/dev/null
	readonly crudeOurPath="$(pwd)"
	popd >/dev/null
}

function exitError()
{
	local -r error="$1"
	echo "$ourName: $error" 1>&2
	exit 1
}

function exitHelp()
{
	echo -n -E "Usage: ${ourName} -h
Usage: ${ourName} [-c configPath] [-s cachePath] [-p pathsPath] [-o option] -- machines...

Defaults
    configPath         ${configPath}
    cachePath          ${cachePath}
    pathsPath          ${pathsPath}
    option             See below

A path is used to define the location of essential programs used during initial bootstrapping. It also defines a packageManager
to automatically install any missing dependencies. The PATH variable is reset to the location of these programs.

Options
For options, prefix with either 'yes-' to turn it on
or 'no-' to turn it off. For example, to turn on 'verbose' :-

    ${ourName} -o yes-verbose

-o may be repeated as necessary. Options are evaluated in left-to-right order.
Last setting wins.

Options are as follows:-   Default
    verbose                ${optionVerbose}
" 1>&2
	exit $1
}

function parseCommandLine()
{	
	configPath="${crudeOurPath}/config"
	cachePath="$configPath"/cache
	pathsPath="$configPath"/paths
	optionVerbose="no"
	
	local OPTERR=1
	local OPTIND=1
	local OPTARG
	local option
	while getopts :hc:s:p:o: option
	do
		case "$option" in
			
			h)
				exitHelp 2
			;;
			
			c)
				configPath="$OPTARG"
			;;
			
			s)
				cachePath="$OPTARG"
			;;
			
			p)
				pathsPath="$OPTARG"
			;;
			
			o)
				if [ -z "$OPTARG" ]; then
					exitError "Invalid option -o requires an argument"
				fi
			
				case "$OPTARG" in
					
					no-verbose)
						optionVerbose="no"
					;;
					
					yes-verbose)
						optionVerbose="yes"
					;;
					
					*)
						exitError "Invalid option -o ${OPTARG}"
					;;
					
				esac
			;;
			
			'?')
				exitError "Invalid option -${OPTARG}"
			;;
			
		esac
	done
	
	shift $((OPTIND - 1))
	if [ $# -eq 0 ]; then
		exitError "Please specify at least one machine"
	fi
	
	machines=("$@")
}

declare -a machines=()

function setConfigPath()
{
	if [ ! -d "$configPath" ]; then
		exitError "Config path $configPath does not exist or is not a directory"
	fi
	pushd "$configPath">/dev/null
	configPath="$(pwd)"
	popd >/dev/null
}

function setCachePath()
{
	if [ ! -d "$cachePath" ]; then
		exitError "Cache path $cachePath does not exist or is not a directory"
	fi
	pushd "$cachePath">/dev/null
	cachePath="$(pwd)"
	popd >/dev/null
}

function setPathsPath()
{
	if [ ! -d "$pathsPath" ]; then
		exitError "Paths path $pathsPath does not exist or is not a directory"
	fi
	pushd "$pathsPath">/dev/null
	pathsPath="$(pwd)"
	popd >/dev/null
}

function setPaths()
{
	setConfigPath
	setCachePath
	setPathsPath
	
	readonly machinesPath="$configPath"/machines
	mkdir -m 0755 -p "$machinesPath"
}

function determineDistribution()
{
	if [ -f /etc/centos-release ]; then
		readonly pathName="centos"
		return 0
	fi
	if [ -f /etc/lsb_release ]; then
		source /etc/lsb_release
		readonly pathName="$DISTRIB_ID"
		return 0
	fi
	
	readonly pathName="debian"
}

function verifyHostSystemRequirementsUsingDependencyChecks()
{
	declare -a dependencies=()
	
	readonly pathNames="$pathsPath"/"$pathName"
	if [ ! -d "$pathNames" ]; then
		exitError "path name $pathNames does not exist or is not a directory"
	fi
	
	readonly pathNamesFunction="$pathsPath"/"$pathName".path
	if [ ! -f "$pathNamesFunction" ]; then
		exitError "path name functions $pathNamesFunction does not exist or is not a directory"
	fi
	
	# Installs the packageManager function
	source "$pathNamesFunction"
	
	declare -a installPackages=()
	local packagePath
	local packageName
	local symlink
	local ourPath=""
	for packagePath in "$pathNames"/*
	do
		if [ ! -d "$packagePath" ]; then
			continue
		fi
		if [ -z "$ourPath" ]; then
			ourPath="$packagePath"
		else
			ourPath="$ourPath":"$packagePath"
		fi
		packageName="$(purebash_basename "$packagePath")"
		
		# Do not check dependencies that are already installed
		if [ "$packageName" = "zzz-built-in" ]; then
			continue
		fi
		
		for symlink in "$packagePath"/*
		do
			if [ -L "$symlink" ]; then
				# Not perfect; might point to non-exec but extant file
				if [ ! -x "$symlink" ]; then
					installPackages+=("$packageName")
					informationMessage WARN "Uninstalled package $packageName"
					break
				fi
			fi
		done
	done
	
	if [ ${#installPackages[@]} -ne 0 ]; then
		informationMessage TASK "Installing missing packages"
		if [ "$verbose" = "yes" ]; then
			packageManager "${installPackages[@]}"
		else
			packageManager "${installPackages[@]}" 1>/dev/null
		fi
		informationMessage PASS "Installing missing packages"
	fi
	
	export PATH="$ourPath"
}

function prepareMachinePaths()
{
	configMachinePath="$machinesPath"/"$machine"
	if [ ! -d "$configMachinePath" ]; then
		informationMessage FAIL "Machine $machine missing machine config path $configMachinePath"
		exit 1
	fi
	
	configMachinePackagesPath="$configMachinePath"/packages.txt
	if [ ! -f "$configMachinePackagesPath" ]; then
		informationMessage FAIL "Machine $machine missing machine packages file $configMachinePackagesPath"
		exit 1
	fi
	
	configMachineInitPath="$configMachinePath"/init
	if [ ! -x "$configMachineInitPath" ]; then
		informationMessage FAIL "Machine $machine missing (or not executable 0755) machine init file $configMachinePackagesPath"
		exit 1
	fi
	
	configMachineDevicesPath="$configMachinePath"/devices
	if [ ! -f "$configMachineDevicesPath" ]; then
		informationMessage FAIL "Machine $machine missing machine devices file $configMachineDevicesPath"
		exit 1
	fi
	
	configMachineRootPath="$configMachinePath"/root
	if [ ! -d "$configMachineRootPath" ]; then
		informationMessage FAIL "Machine $machine missing machine root folder $configMachineRootPath"
		exit 1
	fi
	
	configMachineYumConfigTemplateFile="$configMachinePath"/yum/yum.conf.template
	if [ ! -f "$configMachineYumConfigTemplateFile" ]; then
		informationMessage FAIL "Machine $machine missing machine yum.conf.template file $configMachineYumConfigTemplateFile"
		exit 1
	fi
	if [ ! -d "$configMachinePath"/yum/plugins ]; then
		informationMessage FAIL "Machine $machine missing machine folder $configMachineYumConfigTemplateFile/plugins"
		exit 1
	fi
	if [ ! -d "$configMachinePath"/yum/repositories ]; then
		informationMessage FAIL "Machine $machine missing machine folder $configMachineYumConfigTemplateFile/repositories"
		exit 1
	fi
	
	cacheMachinePath="$cachePath"/"$machine"
	mkdir -m 0755 -p "$cacheMachinePath"
	mkdir -m 0755 -p "$cacheMachinePath"/yum
	mkdir -m 0755 -p "$cacheMachinePath"/yum/cache
	touch "$cacheMachinePath"/yum/log
	chmod 0755 "$cacheMachinePath"/yum/log
	mkdir -m 0755 -p "$cacheMachinePath"/yum/persist
	
	cacheMachineMinimalAppliancePath="$cacheMachinePath"/minimal-appliance
	mkdir -m 0755 -p "$cacheMachineMinimalAppliancePath"
	
	cacheMachineBuiltAppliancePath="$cacheMachinePath"/built-appliance
	mkdir -m 0755 -p "$cacheMachineBuiltAppliancePath"
}

function readMachineConfig()
{
	machinePackageNames=()
	local packageName
	while IFS= read -r packageName
	do
		machinePackageNames+=("$packageName")
	done < <(cat "$configMachinePackagesPath")
}

function fillInMachineYumConfTemplate()
{
	temporaryFileToRemoveOnExit
	configMachineYumConfigFile="$TMP_FILE"
	configMachinePath="$configMachinePath" cacheMachinePath="$cacheMachinePath" templateFile "$configMachineYumConfigTemplateFile" >"$configMachineYumConfigFile"
}

function prepareMachineMinimalAppliance()
{
	supermin --prepare "${machinePackageNames[@]}" --packager-config "$configMachineYumConfigFile" -o "$cacheMachineMinimalAppliancePath"
	
	# Should include the init script as /init
	pushd "$configMachinePath" 1>/dev/null 2>/dev/null
		tar --create --gzip --file "$cacheMachineMinimalAppliancePath"/init.tar.gz init
	popd 1>/dev/null 2>/dev/null
}

function installDeviceNodes()
{
	temporaryFolderToRemoveOnExit
	local installPath="$TMP_FILE"
	
	local devicePath
	local deviceType
	local deviceMode
	local deviceMajor
	local deviceMinor
	local parentPath
	local completePath
	while IFS=' ' read -r devicePath deviceType deviceMode deviceMajor deviceMinor
	do
		parentPath="$(purebash_dirname "$devicePath")"
		fakeroot mkdir -m 0755 -p "${installPath}$parentPath"
		
		completePath="${installPath}$devicePath"
		if [ -e "$completePath" ]; then
			informationMessage WARN "Deleting duplicate device $devicePath"
			rm "$completePath"
		fi
		
		if [ "$deviceType" = 'p' ]; then
			if [ -n "$deviceMajor" ]; then
				informationMessage FAIL "$configMachineDevicesPath contains a FIFO definition $devicePath with a device major"
			fi
			if [ -n "$deviceMinor" ]; then
				informationMessage FAIL "$configMachineDevicesPath contains a FIFO definition $devicePath with a device major"
			fi
			
			fakeroot mknod --mode="$deviceMode" "$completePath" "$deviceType"
		else
			fakeroot mknod --mode="$deviceMode" "$completePath" "$deviceType" "$deviceMajor" "$deviceMinor"
		fi
	done < <(cat "$configMachineDevicesPath")
	
	pushd "$installPath" 1>/dev/null 2>/dev/null
		fakeroot tar --create --gzip --file "$cacheMachineMinimalAppliancePath"/zzz-devices.tar.gz *
	popd 1>/dev/null 2>/dev/null
}

function installAdditionalRootFileSystem()
{
	pushd "$configMachineRootPath" 1>/dev/null 2>/dev/null
		fakeroot tar --create --gzip --file "$cacheMachineMinimalAppliancePath"/zzz-root.tar.gz *
	popd 1>/dev/null 2>/dev/null
}

function buildMachineBuiltAppliance()
{
	supermin --build \
		--format ext2 \
		--copy-kernel \
		--host-cpu "$(uname -m)" \
		--if-newer \
		--lock /run/user/"$(id -u)"/supermin.lock \
		-o "$cacheMachineBuiltAppliancePath" \
		"$cacheMachineMinimalAppliancePath"
}

function informMachineBuilt()
{
	informationMessage INFO "Run with  qemu-kvm -m 512 -kernel kernel -initrd initrd -append 'vga=773 selinux=0' -drive file=root,format=raw,if=virtio"
}

function buildMachines()
{
	local machine
	local configMachinePath
	local configMachinePackagesPath
	local configMachineInitPath
	local configMachineDevicesPath
	local configMachineRootPath
	local cacheMachinePath
	local cacheMachineMinimalAppliancePath
	local cacheMachineBuiltAppliancePath
	declare -a machinePackageNames=()
	for machine in "${machines[@]}"
	do
		prepareMachinePaths
		readMachineConfig
		fillInMachineYumConfTemplate
		prepareMachineMinimalAppliance
		installDeviceNodes
		installAdditionalRootFileSystem
		buildMachineBuiltAppliance
		informMachineBuilt
	done
}

function main()
{
	setDebugging
	findOurNameAndPath
	parseCommandLine "$@"
	ensureWeAreRunningBash4
	initialiseTraps
	setPaths
	determineDistribution
	verifyHostSystemRequirementsUsingDependencyChecks
	buildMachines
}

main "$@"

# TODO: Template-possible root file system
# TODO: Generation of root file system content (eg hostname)
